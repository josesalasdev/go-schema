
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>validator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/josesalasdev/go-schema/validator/errors.go (0.0%)</option>
				
				<option value="file1">github.com/josesalasdev/go-schema/validator/utils.go (94.1%)</option>
				
				<option value="file2">github.com/josesalasdev/go-schema/validator/validator.go (90.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package validator

import "fmt"

func (e ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s: %s", e.Field, e.Message)
}</span>

type ErrorMessages struct {
        Required     *string `json:"required,omitempty"`
        TypeMismatch *string `json:"type_mismatch,omitempty"`
        MinLength    *string `json:"min_length,omitempty"`
        MaxLength    *string `json:"max_length,omitempty"`
        Min          *string `json:"min,omitempty"`
        Max          *string `json:"max,omitempty"`
        Regex        *string `json:"regex,omitempty"`
        CustomError  *string `json:"custom_error,omitempty"`
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package validator

// Add these functions to your validator.go file

// extractIntValue extracts an int64 value from different numeric types
func extractIntValue(value interface{}) (int64, bool) <span class="cov6" title="26">{
        switch v := value.(type) </span>{
        case int:<span class="cov5" title="11">
                return int64(v), true</span>
        case int8:<span class="cov1" title="1">
                return int64(v), true</span>
        case int16:<span class="cov1" title="1">
                return int64(v), true</span>
        case int32:<span class="cov1" title="1">
                return int64(v), true</span>
        case int64:<span class="cov1" title="1">
                return v, true</span>
        case uint:<span class="cov1" title="1">
                return int64(v), true</span>
        case uint8:<span class="cov1" title="1">
                return int64(v), true</span>
        case uint16:<span class="cov1" title="1">
                return int64(v), true</span>
        case uint32:<span class="cov1" title="1">
                return int64(v), true</span>
        case uint64:<span class="cov0" title="0">
                return int64(v), true</span>
        case float32:<span class="cov2" title="2">
                if float32(int64(v)) == v </span><span class="cov1" title="1">{
                        return int64(v), true
                }</span>
        case float64:<span class="cov2" title="2">
                if float64(int64(v)) == v </span><span class="cov1" title="1">{
                        return int64(v), true
                }</span>
        }
        <span class="cov3" title="5">return 0, false</span>
}

// extractFloatValue extracts a float64 value from different numeric types
func extractFloatValue(value interface{}) (float64, bool) <span class="cov5" title="16">{
        switch v := value.(type) </span>{
        case float64:<span class="cov2" title="3">
                return v, true</span>
        case float32:<span class="cov1" title="1">
                return float64(v), true</span>
        case int:<span class="cov1" title="1">
                return float64(v), true</span>
        case int8:<span class="cov1" title="1">
                return float64(v), true</span>
        case int16:<span class="cov1" title="1">
                return float64(v), true</span>
        case int32:<span class="cov1" title="1">
                return float64(v), true</span>
        case int64:<span class="cov1" title="1">
                return float64(v), true</span>
        case uint:<span class="cov1" title="1">
                return float64(v), true</span>
        case uint8:<span class="cov1" title="1">
                return float64(v), true</span>
        case uint16:<span class="cov1" title="1">
                return float64(v), true</span>
        case uint32:<span class="cov1" title="1">
                return float64(v), true</span>
        case uint64:<span class="cov0" title="0">
                return float64(v), true</span>
        }
        <span class="cov2" title="3">return 0, false</span>
}

// isValidJSONKey returns true if the key is a valid JSON key
func isValidJSONKey(key string) bool <span class="cov7" title="32">{
        // Un JSON key válido no debe contener caracteres de control ni espacios en blanco
        for _, r := range key </span><span class="cov10" title="164">{
                if r &lt;= 0x1F || r == ' ' </span><span class="cov4" title="6">{ // Caracteres de control y espacio
                        return false
                }</span>
        }
        <span class="cov6" title="26">return true</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package validator

import (
        "fmt"
        "reflect"
)

/*
This function is a fundamental part of schemas.
Its purpose is to check if a provided value matches an expected type.
*/
func matchesType(value interface{}, expectedType string) bool <span class="cov9" title="49">{
        t := reflect.TypeOf(value)

        switch expectedType </span>{
        case "string":<span class="cov7" title="20">
                return t.Kind() == reflect.String</span>
        case "int":<span class="cov6" title="11">
                // Permitir int, int64 y detectar float64 con valores enteros
                if t.Kind() == reflect.Int || t.Kind() == reflect.Int64 </span><span class="cov6" title="10">{
                        return true
                }</span>
                <span class="cov1" title="1">if t.Kind() == reflect.Float64 </span><span class="cov0" title="0">{
                        return value == float64(int(value.(float64))) // Verifica si es un entero real
                }</span>
                <span class="cov1" title="1">return false</span>
        case "float":<span class="cov2" title="2">
                return t.Kind() == reflect.Float32 || t.Kind() == reflect.Float64</span>
        case "bool":<span class="cov4" title="4">
                return t.Kind() == reflect.Bool</span>
        case "list":<span class="cov4" title="5">
                return t.Kind() == reflect.Slice || t.Kind() == reflect.Array</span>
        case "map":<span class="cov5" title="7">
                return t.Kind() == reflect.Map</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// validateNumeric checks if a numeric value conforms to the specified rules.
func validateNumeric(value interface{}, rule Rule) (bool, string) <span class="cov6" title="12">{
        if rule.Type == "int" </span><span class="cov6" title="10">{
                intVal, ok := extractIntValue(value)
                if !ok </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf("Failed to convert %v to integer", value)
                }</span>
                <span class="cov6" title="10">if rule.Min != 0 &amp;&amp; intVal &lt; int64(rule.Min) </span><span class="cov3" title="3">{
                        return false, fmt.Sprintf("Value %d is less than minimum %d", intVal, int64(rule.Min))
                }</span>
                <span class="cov5" title="7">if rule.Max != 0 &amp;&amp; intVal &gt; int64(rule.Max) </span><span class="cov2" title="2">{
                        return false, fmt.Sprintf("Value %d is greater than maximum %d", intVal, int64(rule.Max))
                }</span>
        } else<span class="cov2" title="2"> if rule.Type == "float" </span><span class="cov2" title="2">{
                floatVal, ok := extractFloatValue(value)
                if !ok </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf("Failed to convert %v to float", value)
                }</span>
                <span class="cov2" title="2">if rule.Min != 0 &amp;&amp; floatVal &lt; float64(rule.Min) </span><span class="cov1" title="1">{
                        return false, fmt.Sprintf("Value %f is less than minimum %f", floatVal, rule.Min)
                }</span>
                <span class="cov1" title="1">if rule.Max != 0 &amp;&amp; floatVal &gt; float64(rule.Max) </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf("Value %f is greater than maximum %f", floatVal, rule.Max)
                }</span>
        }
        <span class="cov5" title="6">return true, ""</span>
}

// validateString checks if a string value conforms to the specified rules.
func validateString(value string, rule Rule) (bool, string) <span class="cov7" title="15">{
        if rule.MinLength != 0 &amp;&amp; len(value) &lt; rule.MinLength </span><span class="cov1" title="1">{
                return false, fmt.Sprintf("String length %d is less than minimum %d", len(value), rule.MinLength)
        }</span>
        <span class="cov7" title="14">if rule.MaxLength != 0 &amp;&amp; len(value) &gt; rule.MaxLength </span><span class="cov1" title="1">{
                return false, fmt.Sprintf("String length %d is greater than maximum %d", len(value), rule.MaxLength)
        }</span>
        <span class="cov6" title="13">if rule.Regex != nil &amp;&amp; !rule.Regex.MatchString(value) </span><span class="cov0" title="0">{
                return false, "String does not match pattern"
        }</span>
        <span class="cov6" title="13">return true, ""</span>
}

// ValidateSchema checks if the provided schema is valid.
func ValidateSchema(schema Schema) error <span class="cov7" title="18">{
        validTypes := map[string]bool{
                "string": true, "int": true, "float": true,
                "bool": true, "list": true, "map": true,
        }

        for field, rule := range schema </span><span class="cov8" title="24">{
                // 1. Validar nombre del campo
                if !isValidJSONKey(field) </span><span class="cov2" title="2">{
                        return fmt.Errorf("invalid field name: '%s'", field)
                }</span>

                // 2. Validar tipo
                <span class="cov8" title="22">if _, ok := validTypes[rule.Type]; !ok </span><span class="cov4" title="4">{
                        return fmt.Errorf("invalid type '%s' for field '%s'", rule.Type, field)
                }</span>

                // 3. Validar valores por defecto
                <span class="cov7" title="18">if rule.Default != nil &amp;&amp; !matchesType(rule.Default, rule.Type) </span><span class="cov2" title="2">{
                        return fmt.Errorf("default value for '%s' does not match type '%s'", field, rule.Type)
                }</span>

                // 4. Validar Min y Max solo en números
                <span class="cov7" title="16">if (rule.Min != 0 || rule.Max != 0) &amp;&amp; rule.Type != "int" &amp;&amp; rule.Type != "float" </span><span class="cov2" title="2">{
                        return fmt.Errorf("min/max can only be used for numeric fields, but found in '%s'", field)
                }</span>

                // 5. Validar listas y mapas anidados
                <span class="cov7" title="14">if rule.Type == "list" &amp;&amp; rule.List != nil </span><span class="cov3" title="3">{
                        if err := ValidateSchema(Schema{"items": *rule.List}); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("invalid list schema in '%s': %v", field, err)
                        }</span>
                }

                <span class="cov6" title="13">if rule.Type == "map" &amp;&amp; rule.Schema != nil </span><span class="cov3" title="3">{
                        if err := ValidateSchema(*rule.Schema); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("invalid map schema in '%s': %v", field, err)
                        }</span>
                }
        }

        <span class="cov5" title="6">return nil</span>
}

// Validate checks if the provided data conforms to the specified schema and returns a ValidationResult.
//
// This function performs multiple validation steps:
// 1. Checks that all fields in the data match their defined types in the schema
// 2. Performs type-specific validations:
//   - For numeric types (int, float): validates range constraints
//   - For string type: validates length and other string-specific rules
//   - For list type: recursively validates each item in the list
//   - For map type: recursively validates the nested structure
//
// 3. Verifies that all required fields are present
//
// The function supports custom error messages defined in the schema for different validation failures.
//
// Parameters:
//   - data: A map containing the data to validate
//   - schema: The schema defining validation rules for each field
//
// Returns:
//
//        A ValidationResult containing:
//        - IsValid: A boolean indicating whether all validations passed
//        - Errors: A slice of ValidationError objects describing each validation failure
func Validate(data map[string]interface{}, schema Schema) ValidationResult <span class="cov9" title="39">{
        var validationErrors []ValidationError

        // Validate provided data against schema
        for field, value := range data </span><span class="cov9" title="46">{
                rule, exists := schema[field]
                if !exists </span><span class="cov1" title="1">{
                        continue</span> // Skip fields not in schema
                }

                // Type validation
                <span class="cov9" title="45">if !matchesType(value, rule.Type) </span><span class="cov4" title="5">{
                        msg := fmt.Sprintf("Invalid type: expected %s, got %T", rule.Type, value)
                        if rule.Messages != nil &amp;&amp; rule.Messages.TypeMismatch != nil </span><span class="cov0" title="0">{
                                msg = *rule.Messages.TypeMismatch
                        }</span>
                        <span class="cov4" title="5">validationErrors = append(validationErrors, ValidationError{Field: field, Message: msg})
                        continue</span>
                }

                // Type-specific validations
                <span class="cov9" title="40">switch rule.Type </span>{
                case "int", "float":<span class="cov6" title="12">
                        if valid, errMsg := validateNumeric(value, rule); !valid </span><span class="cov5" title="6">{
                                if rule.Messages != nil &amp;&amp; rule.Messages.Range != nil </span><span class="cov0" title="0">{
                                        errMsg = *rule.Messages.Range
                                }</span>
                                <span class="cov5" title="6">validationErrors = append(validationErrors, ValidationError{Field: field, Message: errMsg})</span>
                        }
                case "string":<span class="cov7" title="15">
                        if strVal, ok := value.(string); ok </span><span class="cov7" title="15">{
                                if valid, errMsg := validateString(strVal, rule); !valid </span><span class="cov2" title="2">{
                                        if rule.Messages != nil &amp;&amp; rule.Messages.Length != nil </span><span class="cov0" title="0">{
                                                errMsg = *rule.Messages.Length
                                        }</span>
                                        <span class="cov2" title="2">validationErrors = append(validationErrors, ValidationError{Field: field, Message: errMsg})</span>
                                }
                        }
                case "list":<span class="cov4" title="5">
                        if listVal, ok := value.([]interface{}); ok &amp;&amp; rule.List != nil </span><span class="cov4" title="5">{
                                for i, item := range listVal </span><span class="cov6" title="9">{
                                        itemData := map[string]interface{}{"items": item}
                                        result := Validate(itemData, Schema{"items": *rule.List})
                                        if !result.IsValid </span><span class="cov2" title="2">{
                                                for _, err := range result.Errors </span><span class="cov2" title="2">{
                                                        validationErrors = append(validationErrors, ValidationError{
                                                                Field:   fmt.Sprintf("%s[%d]", field, i),
                                                                Message: err.Message,
                                                        })
                                                }</span>
                                        }
                                }
                        }
                case "map":<span class="cov5" title="7">
                        if mapVal, ok := value.(map[string]interface{}); ok &amp;&amp; rule.Schema != nil </span><span class="cov5" title="7">{
                                result := Validate(mapVal, *rule.Schema)
                                if !result.IsValid </span><span class="cov2" title="2">{
                                        for _, err := range result.Errors </span><span class="cov4" title="4">{
                                                validationErrors = append(validationErrors, ValidationError{
                                                        Field:   fmt.Sprintf("%s.%s", field, err.Field),
                                                        Message: err.Message,
                                                })
                                        }</span>
                                }
                        }
                }
        }

        // Check for required fields
        <span class="cov9" title="39">for field, rule := range schema </span><span class="cov10" title="50">{
                if rule.Required </span><span class="cov6" title="9">{
                        if _, exists := data[field]; !exists </span><span class="cov4" title="4">{
                                msg := "Field is required"
                                if rule.Messages != nil &amp;&amp; rule.Messages.Required != nil </span><span class="cov1" title="1">{
                                        msg = *rule.Messages.Required
                                }</span>
                                <span class="cov4" title="4">validationErrors = append(validationErrors, ValidationError{Field: field, Message: msg})</span>
                        }
                }
        }

        <span class="cov9" title="39">return ValidationResult{
                IsValid: len(validationErrors) == 0,
                Errors:  validationErrors,
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
